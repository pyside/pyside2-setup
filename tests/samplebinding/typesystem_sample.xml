<?xml version="1.0"?>
<typesystem package="sample">
    <primitive-type name="bool"/>
    <primitive-type name="double"/>
    <primitive-type name="int"/>
    <primitive-type name="short"/>
    <primitive-type name="unsigned int" />
    <primitive-type name="signed int" />
    <primitive-type name="char"/>
    <primitive-type name="unsigned char"/>
    <primitive-type name="long"/>
    <primitive-type name="unsigned long"/>
    <primitive-type name="std::string"/>

    <primitive-type name="Complex" target-lang-api-name="PyComplex">
        <conversion-rule file="complex_conversions.h"/>
        <include file-name="complex.h" location="global"/>
    </primitive-type>

    <primitive-type name="Null">
        <conversion-rule file="null_conversions.h"/>
        <include file-name="null.h" location="global"/>
    </primitive-type>

    <primitive-type name="HANDLE">
        <conversion-rule file="handle_conversions.h"/>
        <include file-name="handle.h" location="local"/>
    </primitive-type>

    <primitive-type name="OddBool" target-lang-api-name="PyBool">
        <conversion-rule file="oddbool_conversions.h"/>
        <include file-name="oddbool.h" location="global"/>
    </primitive-type>

    <container-type name="std::pair" type="pair">
        <conversion-rule file="pair_conversions.h"/>
        <include file-name="utility" location="global"/>
    </container-type>
    <container-type name="std::list" type="list">
        <conversion-rule file="list_conversions.h"/>
        <include file-name="list" location="global"/>
    </container-type>
    <container-type name="std::map" type="map">
        <conversion-rule file="map_conversions.h"/>
        <include file-name="map" location="global"/>
    </container-type>
    <container-type name="List" type="list" />

    <function signature="sumComplexPair(std::pair&lt;Complex, Complex>)" />
    <function signature="gimmeComplexList()" />
    <function signature="transmuteComplexIntoPoint(const Complex&amp;)" />
    <function signature="transmutePointIntoComplex(const Point&amp;)" />
    <function signature="sumComplexPair(std::pair&lt;Complex, Complex>)" />
    <function signature="doubleUnsignedInt(unsigned int)" />
    <function signature="doubleShort(short)" />
    <function signature="returnNullPrimitivePointer()" />
    <function signature="returnNullValueTypePointer()" />
    <function signature="returnNullObjectTypePointer()" />
    <function signature="acceptInt(int)" />
    <function signature="acceptUInt(unsigned int)" />
    <function signature="acceptLong(long)" />
    <function signature="acceptULong(unsigned long)" />
    <function signature="acceptDouble(double)" />
    <function signature="countCharacters(const char*)" />
    <function signature="gimmeInt()" />
    <function signature="gimmeDouble()" />
    <function signature="makeCString()" />
    <function signature="multiplyPair(std::pair&lt;double, double>)" />
    <function signature="returnCString()" />
    <function signature="overloadedFunc(double)" />
    <function signature="overloadedFunc(int)" />

    <enum-type name="OverloadedFuncEnum"/>
    <!-- BUG:
    renaming the ICOverloadedFuncEnum to the same name
    of a global enum causes the generator to confuse the
    two types.
    -->
    <enum-type name="GlobalEnum"/>
    <enum-type name="GlobalOverloadFuncEnum"/>

    <enum-type identified-by-value="AnonymousGlobalEnum_Value0"/>

    <namespace-type name="SampleNamespace">
        <enum-type name="Option"/>
        <enum-type name="InValue"/>
        <enum-type name="OutValue"/>
        <enum-type identified-by-value="AnonymousClassEnum_Value1"/>

        <object-type name="DerivedFromNamespace">
            <enum-type name="SampleNamespace"/>
        </object-type>
        <value-type name="SomeClass">
            <value-type name="SomeInnerClass">
                <object-type name="OkThisIsRecursiveEnough">
                    <enum-type name="NiceEnum" />
                </object-type>
            </value-type>
        </value-type>

        <modify-function signature="doSomethingWithArray(const unsigned char*, unsigned int, const char*)">
            <modify-argument index="1">
                <replace-type modified-type="const char*"/>
                <conversion-rule class="native">
                    unsigned char* %out = reinterpret_cast&lt;unsigned char*>(PyString_AS_STRING(%PYARG_1));
                </conversion-rule>
            </modify-argument>
            <modify-argument index="2">
                <remove-argument/>
                <conversion-rule class="native">
                    unsigned int %out = static_cast&lt;unsigned int>(PyString_GET_SIZE(%PYARG_1));
                </conversion-rule>
            </modify-argument>
        </modify-function>
        <add-function signature="ImInsideANamespace(int, int)" return-type="int">
            <inject-code class="target">
                %PYARG_0 = %CONVERTTOPYTHON[int](%1 + %2);
            </inject-code>
        </add-function>
    </namespace-type>

    <value-type name="IntList" />

    <object-type name="Abstract">
        <enum-type name="Type"/>
        <enum-type name="PrintFormat"/>
        <modify-function signature="id()" rename="id_"/>
        <modify-function signature="hideFunction(HideType*)" remove="all"/>
    </object-type>

    <object-type name="Derived" polymorphic-id-expression="%1->type() == Derived::TpDerived">
        <enum-type name="OtherOverloadedFuncEnum"/>
        <value-type name="SomeInnerClass" />
    </object-type>

    <object-type name="ModifiedConstructor">
        <modify-function signature="ModifiedConstructor(int)">
            <modify-argument index="1">
                <replace-type modified-type="PyString"/>
            </modify-argument>
            <inject-code class='target' position='beginning'>
                %0 = new %FUNCTION_NAME(atoi(%CONVERTTOCPP[const char *](%PYARG_1)));
            </inject-code>
        </modify-function>
    </object-type>

    <object-type name="ObjectType" hash-function="objectTypeHash">
        <!-- rename function to avoid Python signature conflit -->
        <modify-function signature="setObject(const Null&amp;)" rename="setNullObject" />

        <modify-function signature="event(Event*)">
            <modify-argument index="1" invalidate-after-use="yes"/>
        </modify-function>
        <modify-function signature="invalidateEvent(Event*)">
            <modify-argument index="1" invalidate-after-use="yes"/>
        </modify-function>
        <modify-function signature="create()">
            <modify-argument index="return">
                <define-ownership owner="target"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="createWithChild()">
            <modify-argument index="return">
                <define-ownership owner="target"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="setParent(ObjectType*)">
            <modify-argument index="this">
                <parent index="1" action="add"/>
            </modify-argument>
        </modify-function>
        <inject-code class="native" position="beginning">
            static void reparent_layout_items(PyObject* parent, PyObject* layout)
            {
                const ObjectTypeList&amp; objChildren = %CONVERTTOCPP[ObjectTypeLayout*](layout)->objects();
                ObjectTypeList::const_iterator it = objChildren.begin();
                for (; it != objChildren.end(); ++it) {
                    if ((*it)->isLayoutType()) {
                        ObjectTypeLayout* l = reinterpret_cast&lt;ObjectTypeLayout*>(*it);
                        reparent_layout_items(parent, %CONVERTTOPYTHON[ObjectTypeLayout*](l));
                        Wrapper::setParent(layout, %CONVERTTOPYTHON[ObjectTypeLayout*](l));
                    } else {
                        Wrapper::setParent(parent, %CONVERTTOPYTHON[ObjectType*](*it));
                    }
                }
            }
        </inject-code>
        <modify-function signature="setLayout(ObjectTypeLayout*)">
            <modify-argument index="1">
                <parent index="this" action="add"/>
            </modify-argument>
            <inject-code class="target" position="end">
                if (%PYARG_1 != Py_None)
                    reparent_layout_items(%PYSELF, %PYARG_1);
            </inject-code>
        </modify-function>
        <modify-function signature="takeChild(ObjectType*)">
            <modify-argument index="return">
                <define-ownership owner="target"/>
                <parent index="this" action="remove"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="takeChild(const Str&amp;)">
            <modify-argument index="return">
                <define-ownership owner="target"/>
                <parent index="this" action="remove"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="findChild(const Str&amp;)">
            <modify-argument index="return">
                <parent index="this" action="add"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="children()const">
          <modify-argument index="return">
            <parent index="this" action="add"/>
          </modify-argument>
        </modify-function>
        <modify-function  signature="createChild(ObjectType*)">
          <modify-argument index="return">
              <define-ownership owner="c++" />
          </modify-argument>
        </modify-function>
    </object-type>
    <object-type name="ObjectTypeLayout">
        <modify-function signature="create()">
            <modify-argument index="return">
                <define-ownership owner="target"/>
            </modify-argument>
        </modify-function>
    </object-type>

    <object-type name="ObjectView">
        <modify-function signature="setModel(ObjectType*)">
            <modify-argument index="1">
                <reference-count action="add"/>
            </modify-argument>
        </modify-function>
    </object-type>


    <value-type name="Event">
        <enum-type name="EventType"/>
    </value-type>

    <value-type name="BlackBox">
        <modify-function signature="keepObjectType(ObjectType*)">
            <modify-argument index="1">
                <define-ownership owner="c++"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="retrieveObjectType(int)">
            <modify-argument index="return">
                <define-ownership owner="target"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="keepPoint(Point*)">
            <modify-argument index="1">
                <define-ownership owner="c++"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="retrievePoint(int)">
            <modify-argument index="return">
                <define-ownership owner="target"/>
            </modify-argument>
        </modify-function>
    </value-type>

    <value-type name="ProtectedNonPolymorphic">
        <modify-function signature="create()">
            <modify-argument index="return">
                <define-ownership owner="target"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="modifiedProtectedSum(int, int)">
            <inject-code class="target" position="beginning">
                %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%CPPSELF.%TYPE::%FUNCTION_NAME(%1, %2) * 10);
            </inject-code>
        </modify-function>
        <modify-function signature="dataTypeName(void*) const" remove="all"/>
        <modify-function signature="dataTypeName(int) const">
            <modify-argument index="1">
                <replace-default-expression with="0"/>
            </modify-argument>
        </modify-function>
        <add-function signature="dataTypeName(PyObject*)const" return-type="const char*">
            <inject-code class="target" position="beginning">
                %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%CPPSELF.%FUNCTION_NAME(%PYARG_1));
            </inject-code>
        </add-function>
    </value-type>

    <value-type name="ProtectedPolymorphic">
        <modify-function signature="create()">
            <modify-argument index="return">
                <define-ownership owner="target"/>
            </modify-argument>
        </modify-function>
    </value-type>

    <value-type name="ProtectedPolymorphicDaughter">
        <modify-function signature="create()">
            <modify-argument index="return">
                <define-ownership owner="target"/>
            </modify-argument>
        </modify-function>
    </value-type>

    <value-type name="ProtectedPolymorphicGrandDaughter">
        <modify-function signature="create()">
            <modify-argument index="return">
                <define-ownership owner="target"/>
            </modify-argument>
        </modify-function>
    </value-type>

    <object-type name="ProtectedVirtualDestructor">
        <modify-function signature="create()">
            <modify-argument index="return">
                <define-ownership owner="target"/>
            </modify-argument>
        </modify-function>
    </object-type>


    <object-type name="ProtectedEnumClass">
        <enum-type name="ProtectedEnum" />
        <enum-type name="PublicEnum" />
    </object-type>

    <value-type name="ProtectedProperty" />

    <template name="boolptr_at_end_fix_beginning">
        bool __ok__;
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](
                %CPPSELF.%TYPE::%FUNCTION_NAME(%ARGUMENT_NAMES, &amp;__ok__)
            );
    </template>

    <template name="boolptr_at_start_fix_beginning">
        bool __ok__;
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](
                %CPPSELF.%TYPE::%FUNCTION_NAME(&amp;__ok__, %ARGUMENT_NAMES)
            );
    </template>

    <template name="boolptr_at_start_and_one_arg_fix_beginning">
        bool __ok__;
        %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](
                %CPPSELF.%TYPE::%FUNCTION_NAME(&amp;__ok__, %2)
            );
    </template>

    <template name="boolptr_fix_end">
        PyObject* _tuple_ = PyTuple_New(2);
        PyTuple_SET_ITEM(_tuple_, 0, %PYARG_0);
        PyObject* _item_ = %CONVERTTOPYTHON[bool](__ok__);
        PyTuple_SET_ITEM(_tuple_, 1, _item_);
        %PYARG_0 = _tuple_;
    </template>

    <template name="return_4_arguments_as_tuple">
        %PYARG_0 = PyTuple_New(4);
        PyTuple_SET_ITEM(%PYARG_0, 0, %CONVERTTOPYTHON[%ARG1_TYPE](%1));
        PyTuple_SET_ITEM(%PYARG_0, 1, %CONVERTTOPYTHON[%ARG2_TYPE](%2));
        PyTuple_SET_ITEM(%PYARG_0, 2, %CONVERTTOPYTHON[%ARG3_TYPE](%3));
        PyTuple_SET_ITEM(%PYARG_0, 3, %CONVERTTOPYTHON[%ARG4_TYPE](%4));
    </template>

    <template name="return_5_arguments_as_tuple">
        %PYARG_0 = PyTuple_New(5);
        PyTuple_SET_ITEM(%PYARG_0, 0, %CONVERTTOPYTHON[%ARG1_TYPE](%1));
        PyTuple_SET_ITEM(%PYARG_0, 1, %CONVERTTOPYTHON[%ARG2_TYPE](%2));
        PyTuple_SET_ITEM(%PYARG_0, 2, %CONVERTTOPYTHON[%ARG3_TYPE](%3));
        PyTuple_SET_ITEM(%PYARG_0, 3, %CONVERTTOPYTHON[%ARG4_TYPE](%4));
        PyTuple_SET_ITEM(%PYARG_0, 4, %CONVERTTOPYTHON[%ARG5_TYPE](%5));
    </template>

    <template name="return_none">
        %PYARG_0 = Py_None;
        Py_INCREF(Py_None);
    </template>

    <object-type name="Modifications">
        <enum-type name="OverloadedModFunc"/>

        <modify-function signature="overloaded(int, bool, int, double)">
            <modify-argument index="2">
                <remove-argument/>
            </modify-argument>
            <inject-code class="target" position="beginning">
                %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](
                        %CPPSELF.%TYPE::%FUNCTION_NAME(%1, true, %3, %4)
                    );
            </inject-code>
        </modify-function>

        <modify-function signature="overloaded(int, bool, int, int)">
            <modify-argument index="3">
                <remove-argument/>
                <replace-default-expression with="321"/>
            </modify-argument>
            <!--
            <modify-argument index="4">
                <remove-default-expression/>
            </modify-argument>
            -->
        </modify-function>

        <modify-function signature="argRemoval0(int, bool, int, int)">
            <modify-argument index="3">
                <remove-argument/>
                <replace-default-expression with="321"/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="end">
                <insert-template name="return_4_arguments_as_tuple"/>
            </inject-code>
        </modify-function>

        <modify-function signature="argRemoval1(int, bool, Point, Point, int)">
            <modify-argument index="3">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="4">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="end">
                <insert-template name="return_5_arguments_as_tuple"/>
            </inject-code>
        </modify-function>

        <modify-function signature="argRemoval1(int, bool, int, bool)">
            <inject-code class="target" position="end">
                <insert-template name="return_none"/>
            </inject-code>
        </modify-function>

        <modify-function signature="argRemoval2(int, bool, Point, Point, int)">
            <modify-argument index="3">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="4">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="end">
                <insert-template name="return_5_arguments_as_tuple"/>
            </inject-code>
        </modify-function>

        <modify-function signature="argRemoval3(int, Point, bool, Point, int)">
            <modify-argument index="2">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="4">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="end">
                <insert-template name="return_5_arguments_as_tuple"/>
            </inject-code>
        </modify-function>

        <modify-function signature="argRemoval4(int, Point, bool, Point, int)">
            <modify-argument index="2">
                <remove-argument/>
                <replace-default-expression with="Point(6, 9)"/>
            </modify-argument>
            <modify-argument index="4">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="end">
                <insert-template name="return_5_arguments_as_tuple"/>
            </inject-code>
        </modify-function>

        <modify-function signature="argRemoval5(int, bool, Point, Point, int)">
            <modify-argument index="1">
                <remove-argument/>
                <replace-default-expression with="100"/>
            </modify-argument>
            <modify-argument index="3">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="4">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="end">
                <insert-template name="return_5_arguments_as_tuple"/>
            </inject-code>
        </modify-function>

        <modify-function signature="argRemoval5(int, bool, int, bool)">
            <modify-argument index="1">
                <remove-argument/>
                <replace-default-expression with="200"/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="end">
                <insert-template name="return_4_arguments_as_tuple"/>
            </inject-code>
        </modify-function>

        <!--
        this alteration will trigger an interesting
        compile time error on the binding
        -->
        <!--
        <modify-function signature="overloaded(int, bool, Point, Point)">
            <modify-argument index="3">
                <remove-argument/>
            </modify-argument>
        </modify-function>
        -->

        <!--
        renaming this signature should remove it from the other
        overloaded methods decision tree
        -->
        <modify-function signature="overloaded(int, bool, Point, Point)" rename="over"/>

        <!--
        'ok' must be removed and the return value will be changed
        to a tuple (PyObject*) containing the expected result plus
        the 'ok' value as a Python boolean
        -->
        <modify-function signature="pointToPair(Point, bool*)">
            <modify-argument index="2">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="beginning">
                <insert-template name="boolptr_at_end_fix_beginning"/>
            </inject-code>
            <inject-code class="target" position="end">
                <insert-template name="boolptr_fix_end"/>
            </inject-code>
        </modify-function>

        <!-- same as 'pointToPair' except that this time 'ok' is the first argument -->
        <modify-function signature="multiplyPointCoordsPlusValue(bool*, Point, double)">
            <modify-argument index="1">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="beginning">
                <insert-template name="boolptr_at_start_fix_beginning"/>
            </inject-code>
            <inject-code class="target" position="end">
                <insert-template name="boolptr_fix_end"/>
            </inject-code>
        </modify-function>

        <!-- completely remove 'plus' from the Python side -->
        <modify-function signature="doublePlus(int, int)">
            <modify-argument index="2">
                <remove-argument/>
            </modify-argument>
        </modify-function>

        <!-- the default value for both arguments must be changed in Python -->
        <modify-function signature="power(int, int)">
            <modify-argument index="1">
                <replace-default-expression with="2"/>
            </modify-argument>
            <modify-argument index="2">
                <replace-default-expression with="1"/>
            </modify-argument>
        </modify-function>

        <!-- in Python set argument default value to 10 -->
        <modify-function signature="timesTen(int)">
            <modify-argument index="1">
                <replace-default-expression with="10"/>
            </modify-argument>
        </modify-function>

        <!-- in Python remove the argument default value -->
        <modify-function signature="increment(int)">
            <modify-argument index="1">
                <remove-default-expression/>
            </modify-argument>
        </modify-function>

        <!-- don't export this method to Python -->
        <modify-function signature="exclusiveCppStuff()" remove="all"/>

        <!-- change the name of this regular method -->
        <modify-function signature="cppMultiply(int, int)" rename="calculateArea"/>

        <!-- change the name of this virtual method -->
        <modify-function signature="className()" rename="name"/>
    </object-type>

    <object-type name="AbstractModifications">
        <!--
        completely removing the pure virtual method from this
        class will generate an #error directive.
        -->
        <!--
        <modify-function signature="pointlessPureVirtualMethod()" remove="all"/>
        -->
    </object-type>

    <value-type name="Reference">
        <modify-function signature="returnMyFirstArg(Reference&amp;)">
            <modify-argument index="return">
                <replace-default-expression with="%1"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="returnMySecondArg(int, Reference&amp;)">
            <modify-argument index="return">
                <replace-default-expression with="%2"/>
            </modify-argument>
        </modify-function>
    </value-type>
    <object-type name="ObjTypeReference">
        <modify-function signature="returnMyFirstArg(ObjTypeReference&amp;)">
            <modify-argument index="return">
                <replace-default-expression with="%1"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="returnMySecondArg(int, ObjTypeReference&amp;)">
            <modify-argument index="return">
                <replace-default-expression with="%2"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="justAPureVirtualFunc(ObjTypeReference&amp;)">
            <modify-argument index="return">
                <replace-default-expression with="%1"/>
            </modify-argument>
        </modify-function>
    </object-type>
    <value-type name="ImplicitConv">
        <enum-type name="CtorEnum"/>
        <enum-type name="ICOverloadedFuncEnum"/>
    </value-type>

    <value-type name="VirtualMethods">
        <modify-function signature="sum0(int, int, int)" rename="sumThree"/>
        <modify-function signature="sum1(int, int, int)">
            <modify-argument index="3">
                <replace-default-expression with="1000"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="sum2(int, int, int)">
            <modify-argument index="3">
                <remove-argument/>
                <replace-default-expression with="2000"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="sum3(int, int, int)">
            <modify-argument index="2">
                <remove-argument/>
            </modify-argument>
            <inject-code class="target" position="beginning">
                %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](
                        %CPPSELF.%TYPE::%FUNCTION_NAME(%1, %1+%3, %3)
                    );
            </inject-code>
        </modify-function>
        <modify-function signature="sum4(int, int, int)">
            <modify-argument index="2">
                <remove-argument/>
                <replace-default-expression with="3000"/>
            </modify-argument>
            <inject-code class="native" position="beginning">
                PyObject* new_arg0 = PyInt_FromLong(PyInt_AS_LONG(%PYARG_1) - %2);
                Py_DECREF(%PYARG_1);
                %PYARG_1 = new_arg0;
            </inject-code>
        </modify-function>
        <modify-function signature="name()">
            <inject-code class="native" position="end">
                %0.prepend(Str("Pimped"));
            </inject-code>
        </modify-function>
        <modify-function signature="callMe()">
            <inject-code class="native" position="end">
                PyObject_Call(%PYTHON_METHOD_OVERRIDE, %PYTHON_ARGUMENTS, NULL);
            </inject-code>
        </modify-function>
        <modify-function signature="createStr(const char*, Str*&amp;)">
            <modify-argument index="2">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PySequence"/>
                <conversion-rule class="native">
                    AutoDecRef _py_ok_(PySequence_GetItem(%PYARG_0, 0));
                    AutoDecRef _py_ret_(PySequence_GetItem(%PYARG_0, 1));
                    %RETURN_TYPE %out = %CONVERTTOCPP[%RETURN_TYPE](_py_ok_);
                    %2 = %CONVERTTOCPP[Str*](_py_ret_);
                </conversion-rule>
            </modify-argument>
            <inject-code class="target" position="beginning">
                Str* _str_arg_ = 0;
                %RETURN_TYPE %0 = %CPPSELF.%TYPE::%FUNCTION_NAME(%1, _str_arg_);
            </inject-code>
            <inject-code class="target" position="end">
                %PYARG_0 = PyTuple_New(2);
                PyObject* _item_ = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
                PyTuple_SET_ITEM(%PYARG_0, 0, _item_);
                _item_ = %CONVERTTOPYTHON[Str*](_str_arg_);
                PyTuple_SET_ITEM(%PYARG_0, 1, _item_);
            </inject-code>
        </modify-function>
        <modify-function signature="callCreateStr(const char*, Str*&amp;)">
            <modify-argument index="2">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PySequence"/>
            </modify-argument>
            <inject-code class="target" position="beginning">
                Str* _str_arg_ = 0;
                %RETURN_TYPE %0 = %CPPSELF.%FUNCTION_NAME(%1, _str_arg_);
            </inject-code>
            <inject-code class="target" position="end">
                %PYARG_0 = PyTuple_New(2);
                PyObject* _item_ = %CONVERTTOPYTHON[%RETURN_TYPE](%0);
                PyTuple_SET_ITEM(%PYARG_0, 0, _item_);
                _item_ = %CONVERTTOPYTHON[Str*](_str_arg_);
                PyTuple_SET_ITEM(%PYARG_0, 1, _item_);
            </inject-code>
        </modify-function>
    </value-type>
    <value-type name="VirtualDaughter" />

    <value-type name="VirtualDtor">
        <modify-function signature="create()">
            <modify-argument index="return">
                <define-ownership owner="target"/>
            </modify-argument>
        </modify-function>
    </value-type>

    <value-type name="PointerHolder">
        <modify-function signature="PointerHolder(void*)" remove="all"/>
        <add-function signature="PointerHolder(PyObject*)">
            <inject-code class="target" position="beginning">
                %0 = new %TYPE(%PYARG_1);
            </inject-code>
        </add-function>
        <modify-function signature="pointer() const">
            <inject-code class="target" position="beginning">
                %PYARG_0 = (PyObject*)%CPPSELF.%FUNCTION_NAME();
                if (!%PYARG_0)
                    %PYARG_0 = Py_None;
                Py_XINCREF(%PYARG_0);
            </inject-code>
        </modify-function>
    </value-type>

    <value-type name="InjectCode">
        <!--
            Various tests for inject codes.
            Note: Some uses of inject code here are used just for testing purposes, consider using the add-function tag.
        -->

        <modify-function signature="sumArrayAndLength(int *) const">
            <modify-argument index="1">
                <replace-type modified-type="PyObject"/>
            </modify-argument>
            <inject-code class="target" position="beginning">
                int* array = NULL;
                bool errorOccurred = false;

                if (PySequence_Check(%PYARG_1)) {
                    if((array = Shiboken::sequenceToIntArray(%PYARG_1, true)) == NULL &amp;&amp; PyErr_Occurred()) {
                        PyErr_SetString(PyExc_TypeError, "Should be a sequence of ints");
                        errorOccurred = true;
                    }
                } else {
                    PyErr_SetString(PyExc_TypeError, "Should be a sequence of ints");
                    errorOccurred = true;
                }

                if (!errorOccurred) {
                    %RETURN_TYPE retval = %CPPSELF.%FUNCTION_NAME(array);

                    if (array)
                        delete[] array;

                    %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](retval);
                }
            </inject-code>

        </modify-function>

        <inject-code class="native" position="beginning">
            // simple class to avoid mem leak inside conversion rule used in arrayMethod
            template&lt;typename T>
            struct ArrayDeleter {
                ArrayDeleter(T* ptr) : m_ptr(ptr) {}
                ~ArrayDeleter() { delete[] m_ptr; }
                operator T*() { return m_ptr; }
            private:
                T* m_ptr;
                ArrayDeleter(const ArrayDeleter&amp;);
                ArrayDeleter&amp; operator=(ArrayDeleter&amp;);
            };
        </inject-code>
        <modify-function signature="arrayMethod(int, int*) const">
            <modify-argument index="1">
                <remove-argument/>
                <conversion-rule class="native">
                  int %out = PySequence_Size(%PYARG_1);
                </conversion-rule>
            </modify-argument>

            <modify-argument index="2">
              <replace-type modified-type="PySequence"/>

              <conversion-rule class="native">
                int numItems = PySequence_Size(%PYARG_1);
                ArrayDeleter&lt;int> %out(new int[numItems]);
                for (int i=0; i &lt; numItems; i++)
                    %out[i] = %CONVERTTOCPP[int](PySequence_GetItem(%PYARG_1, i));
              </conversion-rule>

              <conversion-rule class="target">
                PyObject *%out = PyList_New(count);
                for (int i=0; i &lt; count; i++)
                    PyList_SET_ITEM(%out, i, %CONVERTTOPYTHON[int](%in[i]));
              </conversion-rule>
          </modify-argument>

        </modify-function>

        <modify-function signature="callArrayMethod(int, int*) const">
            <modify-argument index="1">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="2">
                <replace-type modified-type="PySequence"/>
            </modify-argument>
            <inject-code class="target" position="beginning">
                int numItems = PySequence_Size(%PYARG_1);
                int *cppItems = new int[numItems];
                for (int i = 0; i &lt; numItems; i++)
                    cppItems[i] = %CONVERTTOCPP[int](PySequence_GetItem(%PYARG_1, i));
                %PYARG_0 = %CONVERTTOPYTHON[int](%CPPSELF.%FUNCTION_NAME(numItems, cppItems));
                delete[] cppItems;
            </inject-code>
        </modify-function>

        <!--
            Inject the tp_str method using this alternative way
            Tested in InjectCodeTest.testTypeNativeBeginning_TypeTargetBeginning:
        -->
        <inject-code class="native" position="beginning">
        PyObject* InjectCode_tpstr(PyObject*) { return PyString_FromString("Hi! I'm the inject code dummy class."); }
        </inject-code>
        <!--
            Register our tp_str class using another inject code
            Tested in InjectCodeTest.testTypeNativeBeginning_TypeTargetBeginning:
        -->
        <inject-code class="target" position="beginning">
        %PYTHONTYPEOBJECT.tp_str = InjectCode_tpstr;
        </inject-code>

        <!-- Tested in InjectCodeTest.testFunctionTargetBeginning_FunctionTargetEnd -->
        <modify-function signature="simpleMethod1(int, int)">
            <inject-code class="target" position="beginning">
                %1 += 1;
            </inject-code>
            <inject-code class="target" position="end">
                PyObject* tmp = PyString_FromString("end");
                PyString_Concat(&amp;%PYARG_0, tmp);
                Py_DECREF(tmp);
            </inject-code>
        </modify-function>

        <!-- Tested in InjectCodeTest.testFunctionTargetBeginning -->
        <modify-function signature="simpleMethod2()">
            <inject-code class="target" position="end">
                PyObject* tmp = PyString_FromString("end");
                PyString_Concat(&amp;%PYARG_0, tmp);
                Py_DECREF(tmp);
            </inject-code>
        </modify-function>

        <!-- Tested in InjectCodeTest.testArgsModification -->
        <modify-function signature="overloadedMethod(int, char**)">
            <modify-argument index="1">
                <replace-type modified-type="PySequence" />
            </modify-argument>
            <modify-argument index="2">
                <remove-argument />
            </modify-argument>
            <inject-code class="target" position="beginning">
                int argc;
                char** argv;
                if (!sequenceToArgcArgv(%PYARG_1, &amp;argc, &amp;argv)) {
                    PyErr_SetString(PyExc_TypeError, "error");
                    return 0;
                }
                %RETURN_TYPE foo = %CPPSELF.%FUNCTION_NAME(argc, argv);
                %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](foo);

                for (int i = 0; i &lt; argc; ++i)
                    free(argv[i]);
                delete[] argv;
            </inject-code>
        </modify-function>

        <!-- Tested in InjectCodeTest.testArgsModification2 -->
        <modify-function signature="simpleMethod3(int, char**)">
            <modify-argument index="1">
                <replace-type modified-type="PySequence" />
            </modify-argument>
            <modify-argument index="2">
                <remove-argument />
            </modify-argument>
            <inject-code class="target" position="beginning">
                int argc;
                char** argv;
                if (!sequenceToArgcArgv(%PYARG_1, &amp;argc, &amp;argv)) {
                    PyErr_SetString(PyExc_TypeError, "error");
                    return 0;
                }
                %RETURN_TYPE foo = %CPPSELF.%FUNCTION_NAME(argc, argv);
                %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](foo);

                for (int i = 0; i &lt; argc; ++i)
                    free(argv[i]);
                delete[] argv;
            </inject-code>
        </modify-function>
    </value-type>

    <value-type name="ImplicitBase"/>
    <value-type name="SortedOverload">
        <add-function signature="overload(PyObject *)" return-type="const char *">
            <inject-code class="target" position="beginning">
                return PyString_FromString("PyObject");
            </inject-code>
        </add-function>

        <add-function signature="overloadDeep(int, PyObject *)" return-type="const char *">
            <inject-code class="target" position="beginning">
                return PyString_FromString("PyObject");
            </inject-code>
        </add-function>
    </value-type>
    <value-type name="ImplicitTarget"/>

    <value-type name="Point">
        <add-function signature="__str__" return-type="PyObject*">
            <inject-code class="target" position="beginning">
            int x1 = (int) %CPPSELF.x();
            int x2 = ((int) (%CPPSELF.x() * 100)) - (x1 * 100);
            int y1 = (int) %CPPSELF.y();
            int y2 = ((int) (%CPPSELF.y() * 100)) - (y1 * 100);
            %PYARG_0 = PyString_FromFormat("Point(%d.%d, %d.%d)", x1, x2, y1, y2);
            </inject-code>
        </add-function>
        <add-function signature="__repr__" return-type="PyObject*">
            <inject-code class="target" position="beginning">
            int x1 = (int) %CPPSELF.x();
            int x2 = ((int) (%CPPSELF.x() * 10)) - (x1 * 10);
            int y1 = (int) %CPPSELF.y();
            int y2 = ((int) (%CPPSELF.y() * 10)) - (y1 * 10);
            %PYARG_0 = PyString_FromFormat("&lt;Point object at %p: (%d.%d, %d.%d)&gt;", %CPPSELF, x1, x2, y1, y2);
            </inject-code>
        </add-function>

        <add-function signature="__reduce__" return-type="PyObject*">
            <inject-code class="target" position="beginning">
            PyObject *type = PyObject_Type(%PYSELF);
            PyObject *args = NULL;

            args = Py_BuildValue("(dd)", %CPPSELF.x(), %CPPSELF.y());

            %PYARG_0 = Py_BuildValue("(OO)", type, args);
            </inject-code>
        </add-function>
    </value-type>

    <value-type name="PointF">
        <add-function signature="__str__" return-type="PyObject*">
            <inject-code class="target" position="beginning">
            int x1 = (int) %CPPSELF.x();
            int x2 = ((int) (%CPPSELF.x() * 100)) - (x1 * 100);
            int y1 = (int) %CPPSELF.y();
            int y2 = ((int) (%CPPSELF.y() * 100)) - (y1 * 100);
            %PYARG_0 = PyString_FromFormat("PointF(%d.%d, %d.%d)", x1, x2, y1, y2);
            </inject-code>
        </add-function>
        <add-function signature="__repr__" return-type="PyObject*">
            <inject-code class="target" position="beginning">
            int x1 = (int) %CPPSELF.x();
            int x2 = ((int) (%CPPSELF.x() * 10)) - (x1 * 10);
            int y1 = (int) %CPPSELF.y();
            int y2 = ((int) (%CPPSELF.y() * 10)) - (y1 * 10);
            %PYARG_0 = PyString_FromFormat("&lt;PointF object at %p: (%d.%d, %d.%d)&gt;", %CPPSELF, x1, x2, y1, y2);
            </inject-code>
        </add-function>

        <add-function signature="__reduce__" return-type="PyObject*">
            <inject-code class="target" position="beginning">
            PyObject *type = PyObject_Type(%PYSELF);
            PyObject *args = NULL;

            args = Py_BuildValue("(dd)", %CPPSELF.x(), %CPPSELF.y());

            %PYARG_0 = Py_BuildValue("(OO)", type, args);
            </inject-code>
        </add-function>
    </value-type>

    <value-type name="Polygon">
        <modify-function signature="stealOwnershipFromPython(Point*)">
            <modify-argument index="1">
                <define-ownership owner="c++"/>
            </modify-argument>
        </modify-function>
        <modify-function signature="stealOwnershipFromPython(Polygon*)">
            <modify-argument index="1">
                <define-ownership owner="c++"/>
            </modify-argument>
        </modify-function>
    </value-type>

    <value-type name="Time">
        <enum-type name="NumArgs"/>
    </value-type>
    <value-type name="Size">
        <add-function signature="Size(const char*)">
            <inject-code class="target" position="beginning">
                %0 = new %TYPE();
            </inject-code>
            <inject-code class="target" position="end">
                Shiboken::AutoDecRef result(PyObject_CallMethod(%PYSELF, const_cast&lt;char*>("setHeight"), const_cast&lt;char*>("i"), 2));
            </inject-code>
        </add-function>
    </value-type>
    <value-type name="MapUser"/>
    <value-type name="PairUser"/>
    <value-type name="ListUser">
        <enum-type name="ListOfSomething"/>
    </value-type>
    <value-type name="NoImplicitConversion" />
    <value-type name="NonDefaultCtor" />
    <value-type name="OddBoolUser" />
    <value-type name="Overload">
        <enum-type name="FunctionEnum"/>
        <enum-type name="ParamEnum"/>
        <modify-function signature="intOverloads(int, int, double)">
            <modify-argument index="2">
                <remove-argument />
            </modify-argument>
            <inject-code class="target">
                %PYARG_0 = %CONVERTTOPYTHON[%RETURN_TYPE](%CPPSELF.%FUNCTION_NAME(%1, 2, %3));
            </inject-code>
        </modify-function>
        <modify-function signature="singleOverload(Point*)">
            <modify-argument index="1">
                <define-ownership owner="c++"/>
            </modify-argument>
        </modify-function>
    </value-type>
    <object-type name="Collector" stream="yes"/>

    <value-type name="IntWrapper" />

    <value-type name="Str" hash-function="strHash">
        <add-function signature="__str__" return-type="PyObject*">
            <inject-code class="target" position="beginning">
                %PYARG_0 = PyString_FromString(%CPPSELF.cstring());
            </inject-code>
        </add-function>
        <add-function signature="__len__" >
            <inject-code class="target" position="end">
                return %CPPSELF.size();
            </inject-code>
        </add-function>
        <add-function signature="__getitem__" >
            <inject-code class="target" position="beginning">
                if (_i &lt; 0 || _i >= %CPPSELF.size()) {
                    PyErr_BadArgument();
                    return 0;
                } else {
                    char res[2];
                    res[0] = %CPPSELF.get_char(_i);
                    res[1] = 0;
                    return PyString_FromString(res);
                }
            </inject-code>
        </add-function>
        <add-function signature="__setitem__" >
            <inject-code class="target" position="beginning">
                PyObject* args = Py_BuildValue("(iO)", _i, _value);
                PyObject* result = Sbk_StrFunc_set_char(self, args);
                Py_DECREF(args);
                int ok = result == Py_True;
                if (result) {
                    Py_DECREF(result);
                }
                return !ok ? -1 : 0;
            </inject-code>
        </add-function>
        <modify-function signature="toInt(bool*, int)const">
            <modify-argument index="1">
                <remove-argument/>
            </modify-argument>
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="beginning">
                <insert-template name="boolptr_at_start_and_one_arg_fix_beginning"/>
            </inject-code>
            <inject-code class="target" position="end">
                <insert-template name="boolptr_fix_end"/>
            </inject-code>
        </modify-function>
    </value-type>

    <value-type name="StrList">
        <add-function signature="__len__" >
            <inject-code class="target" position="end">
                return %CPPSELF.size();
            </inject-code>
        </add-function>
        <add-function signature="__getitem__" >
            <inject-code class="target" position="beginning">
                if (_i &lt; 0 || _i >= static_cast&lt;Py_ssize_t>(%CPPSELF.size())) {
                    PyErr_BadArgument();
                    return 0;
                } else {
                    %TYPE::const_iterator it = %CPPSELF.begin();
                    for (Py_ssize_t i = 1; i &lt;= _i; i++)
                        ++it;
                    return %CONVERTTOPYTHON[Str](*it);
                }
            </inject-code>
        </add-function>
    </value-type>

    <value-type name="SimpleFile">
        <modify-function signature="open()">
            <modify-argument index="return">
                <remove-argument/>
            </modify-argument>
            <inject-code class="target" position="end" file="simplefile_glue.cpp"/>
        </modify-function>
    </value-type>

    <value-type name="VoidHolder">
        <modify-function signature="gimmeMeSomeVoidPointer()">
            <modify-argument index="return">
                <replace-type modified-type="PyObject*"/>
            </modify-argument>
            <inject-code class="target" position="end">
                %RETURN_TYPE %0 = %TYPE::%FUNCTION_NAME();
                %PYARG_0 = Shiboken::Wrapper::newObject(&amp;SbkObject_Type, %0, false, false);
            </inject-code>
        </modify-function>
    </value-type>

    <object-type name="PrivateCtor" />
    <object-type name="PrivateDtor" />

    <object-type name="Base1"/>
    <interface-type name="Base2"/>
    <object-type name="Base3"/>
    <interface-type name="Base4"/>
    <interface-type name="Base5"/>
    <interface-type name="Base6"/>
    <object-type name="MDerived1"/>
    <object-type name="MDerived2"/>
    <object-type name="MDerived3"/>
    <object-type name="MDerived4"/>
    <object-type name="MDerived5"/>
    <object-type name="SonOfMDerived1"/>

    <object-type name="Bucket">
        <modify-function signature="lock()" allow-thread="yes" />
        <modify-function signature="virtualBlockerMethod()" allow-thread="yes"/>
        <modify-function signature="callVirtualBlockerMethodButYouDontKnowThis()" allow-thread="yes"/>
    </object-type>

    <value-type name="Echo">
        <add-function signature="echo(const char *)" return-type="PyObject*">
            <inject-code class="target" position="beginning">
                %PYARG_0 = PyString_FromString(%1);
            </inject-code>
        </add-function>
    </value-type>

    <add-function signature="multiplyString(PyString*, unsigned int)" return-type="const char*">
        <inject-code class="target" position="beginning">
            %PYARG_0 = PyString_FromString("");
            for (unsigned int i = 0; i &lt; %2; ++i)
                PyString_Concat(&amp;%PYARG_0, %PYARG_1);
        </inject-code>
    </add-function>

    <add-function signature="countVarargs(int, ...)" return-type="int">
        <inject-code class="target" position="beginning">
            %PYARG_0 = %CONVERTTOPYTHON[int](PyTuple_GET_SIZE(%PYARG_2));
        </inject-code>
    </add-function>

    <value-type name="SbkDate">
        <extra-includes>
            <include file-name="datetime.h" location="global"/>
        </extra-includes>
        <conversion-rule class="target" file="date_conversions.h"/>
    </value-type>

    <object-type name="HandleHolder" />

    <!-- type used in abstract method -->
    <object-type name="HideType" generate="no" />

    <rejection class="ListUser" function-name="createList()"/>
    <rejection class="ListUser" function-name="callCreateList()"/>
    <rejection class="ListUser" function-name="createComplexList(Complex, Complex)"/>
    <rejection class="ListUser" function-name="sumList(std::list&lt;int&gt;)"/>
    <rejection class="ListUser" function-name="sumList(std::list&lt;double&gt;)"/>

    <value-type name="ValueAndVirtual" />
    <suppress-warning text="::*" />
    <suppress-warning text="horribly broken type '__off64_t'" />
    <suppress-warning text="enum '__codecvt_result' does not have a type entry or is not an enum" />
</typesystem>

